{"/_app":{"title":" App","data":{"":""}},"/_app":{"title":" App","data":{"":""}},"/cli/create":{"title":"gboost create","data":{"":""}},"/cli/intro":{"title":"CLI Introduction","data":{"":"Welcome to the docs for gboost."}},"/core/intro":{"title":"Core Introduction","data":{"":"Welcome to the docs for gboost-node."}},"/":{"title":"Index","data":{"":""}},"/infra/intro":{"title":"Infra Introduction","data":{"":"Welcome to the docs for gboost-infra."}},"/infra/tips":{"title":"Tips","data":{"":"Don't define all your infrastructure within class constructors, use methods to make your constructs easier to follow."}},"/learn/intro":{"title":"Learn Introduction","data":{"":""}},"/learn/resources":{"title":"Resources","data":{"":"There are tons of great articles/blogs/tutorials available on the web to help you build web apps with Green Boost's tech stack: TypeScript, AWS CDK, React, Node.js. Here is a consolidated list:","aws#AWS":"","aws-cdk#AWS CDK":"","clean-code#Clean Code":"Serverless Clean Code Architecture with Domain Driven Design\nAn Introduction To Domain Driven Design (DDD)\nAWS Prescriptive Guidance: Building hexagonal architectures on AWS\nDomain Driven Hexagon\nA Beginner’s Guide to Domain-centric Architectures (clean, hexagonal, …)\nVertical Slice Architecture","react#React":"","nextjs#Next.js":"Full Stack Airbnb Clone with Next.js 13 App Router: React, Tailwind, Prisma, MongoDB, NextAuth 2023","nodejs#Node.js":"","typescript#TypeScript":""}},"/overview/common-error-resolutions":{"title":"Common Error Resolutions","data":{"":""}},"/overview/contributors/dependencies":{"title":"Dependencies","data":{"":"","dependencies-vs-peer-dependencies#Dependencies vs Peer Dependencies":"When building a React component, CDK construct, or Node.js function that depends on a 3rd party library outside of the core 3rd party dependencies (listed below), make those dependencies optional peer dependencies and do not export the component or construct from the index/root of the package. Export the component or construct from a subpath of the module via package.json#exports so that only consumers of the package who want to use that functionality have to install the 3rd party dependency. Core dependencies include libraries already included in the \"dependencies\" key of the package.json. Each component/construct should include any additional libraries that need to be installed in the docs.","core-3rd-party-dependencies#Core 3rd Party Dependencies":"","gboost-infra#gboost-infra":"aws-cdk-lib\ncdk-nag\nconstructs\ngboost-common","gboost-node#gboost-node":"gboost-common","gboost-ui#gboost-ui":"@emotion/cache\n@emotion/react\n@emotion/styled\n@mui/icons-material\n@mui/material\ngboost-common\nnext\nreact\nreact-dom","update-dependencies#Update Dependencies":"GB dependencies should be updated regularly. To update all patch and minor NPM versions, run pnpm -r up -i. This will launch an interactive CLI UI that allows you to pick which dependencies you want to updated. You can type a to update them all. For patch and minor version updated, you should be safe to do this.You'll also want to check for major package upgrades but tread cautiously as these new versions contain breaking changes that may or may not break GB. For major version upgrades run pnpm -r up -i --latest. For any major upgrades, make sure to check out the realease notes or changelog for the package on GitHub."}},"/overview/contributors/development-workflow":{"title":"Development Workflow","data":{"":"Open an issue here describing your feature or fix.\nCreate a branch using a descriptive name that references the issue like feat-123-description or fix-123-description.\nAdd feature, fix bug, refactor, etc.\nCreate changeset by running pnpm changeset in root of repo. Answer prompts, typically you'll be creating a minor change\nStage changes including changeset file (i.e. git add -A)\nCommit changes. Husky git commits should trigger lint-staged to run validating your staged files\nPush branch and open a PR into awslabs/green-boost's main branch.\nWork with Green Boost team to refactor PR and then wait for PR to be merged!","pull-requests#Pull Requests":"When creating a pull request (PR) that includes functionality that should be documented in the changelog and/or update the version of a package (most changes) be sure to create a changeset. Changesets are files that live within the .changeset folder and are created with pnpm changeset at the root of the green boost repository. You'll be asked what packages the changes were made in and what semantic version level (patch, minor, major) to apply. After you create these files via pnpm changeset, you can edit the generated markdown (within .changeset folder) however you'd like.When a PR is created, several continuous integration (CI) checks are run based on the ci.yml GitHub workflow. It should be required, but please make sure these pass before merging.","releases#Releases":"Changesets is used to create releases. A release includes a git tag and entry in the GitHub releases page of Green Boost. After merging changes into main, the changesets GitHub bot will automatically create a changeset-release/main branch and a PR titled, \"Version Packages\", for the packages that were updated into the main branch. When this PR is merged, the GitHub Workflow publish.yml releasing changes to NPM."}},"/overview/contributors/fix-audit-issues":{"title":"Fix Audit Issues","data":{"":"On each PR, pnpm audit is used to detect CVEs. The GitHub Actions Workflow will fail if any CVEs >= moderate severity are found by running the command pnpm audit --audit-level moderate. If the dependency is a direct dependency of your project, you should try to update dependencies. You can learn why a dependency is in your project (dependency hierarchy) with pnpm why <package-name>. If the dependency is a transitive dependency (dependency of dependency), you'll need to use PNPM's pnpm.overrides feature by adding to the package.json#pnpm.overrides object a key/value pair like: \"<package-name>@<vulnerable-version>\": \"<patched-version>\". Then run pnpm i to update your dependencies.Periodically, pnpm.overrides should be cleaned up as libraries overtime will update to patched version of packages.If there is no patched version of the library and you can safely ignore the CVE, you can add it to pnpm.auditConfig.ignoreCves."}},"/overview/contributors/intro":{"title":"Contributor's Introduction","data":{"":"Hello! Thank you for your interest in contributing to Green Boost. By contributing, you have the opportunity to scale your influence to AWS customers around the world!To get started contributing:\nFork the repository by clicking here\nClone your forked repository like: git clone https://github.com/bestickley/green-boost.git\nChange directory: cd green-boost\nInstall dependencies: pnpm i\nTry running linting: pnpm lint, typechecking: pnpm typecheck or tests: pnpm test."}},"/overview/contributors/resources":{"title":"Node.js","data":{"":"Building a library whether for React components, CDK Constructs, or Node.js takes skill.\nAdvanced React Component Composition Guide\nBuilding Future Facing Frontend Architectures\n\n\nTODO\n\n\nTODO"}},"/overview/contributors/testing-locally":{"title":"Testing Locally","data":{"":"To develop gboost-ui or gboost-infra or gboost-common in your Green Boost application repository (created with gboost create), run pnpm add ../path/to/gboost/packages/gboost-* replacing the path with the path to wherever the package is locally. This will change your package.json.Instructions below allow you to edit .ts files and test out your changes without having to compile to .js each time you make a change.","gboost-ui#gboost-ui":"After running pnpm add ../path/to/gboost/packages/gboost-ui in your GB app ui folder, you'll need to restart the Vite dev server.For any library used in gboost-ui and the consuming package (ui folder), you'll want to add that library to Vite's resolve.dedupe configuration parameter. See an explanation here. Here is an inexhaustive list: [\"aws-amplify\", \"@aws-amplify/ui-react\", \"graphql\", \"graphql-tag\", \"react\", \"react-dom\", \"react-icons\", \"react-router-dom\", \"@vanilla-extract/css\"]","gboost#gboost":"Install vite-node globally with pnpm add -g vite-node. Then you can run the CLI source (TS files) with: vite-node --options.deps.inline=\"@aws-sdk/util-user-agent-node\" ../path/to/green-boost/packages/gboost/src/index.ts -- <command>. You can remove --options.deps.inline=\"@aws-sdk/util-user-agent-node\" once this issue is resolved.","gboost-infra#gboost-infra":"After running pnpm add ../path/to/gboost/packages/gboost-infra in your GB app infra folder you'll have 2 instances of aws-cdk-lib and cdk-nag. One in your project and one in the green-boost repository. This causes an issue for cdk-nag because it uses instanceof comparisons on classes to conditionally check if resources adhere to requirements. See more here. To get around this, we'll use Vite's resolve.dedupe configuration feature. Steps:\nIn infra folder run: pnpm add -D vite vite-node\nAdd vite.config.ts\n\n\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\nresolve: {\ndedupe: [\"aws-cdk-lib\", \"cdk-nag\"],\n},\n});\n\nChange cdk.json#app to \"/path/to/your/app/infra/node_modules/.bin/vite-node src/local-app.ts\"\ncdk synth \"**\". Now only 1 version of those libraries will be used when synthesizing your app.\n\nNote: you'll need to run pnpm build within green-boost/packages/gboost-infra if using constructs that rely on built code like custom resources."}},"/overview/contributors/tips":{"title":"Tips","data":{"":"","javascript#JavaScript":"Avoid export * from \"./some-file\". It makes tracking down imported functions/classes difficult."}},"/overview/faq":{"title":"FAQ","data":{"":"","how-does-green-boost-compare-to-amplify#How does Green Boost compare to Amplify?":"Opinions: Green Boost is more opinionated than Amplify.\nClients: Green Boost supports web. Amplify supports web and mobile.\nLanguages/Frameworks: Green Boost only supports TypeScript and React. Amplify supports multiple languages and frontend frameworks.\nInfrastructure: Green Boost uses the AWS CDK for infrastructure definition and deployment. Amplify uses CloudFormation templates for infrastructure definition (with second class support for CDK) and uses their own Amplify CLI for deployment.\nUI Component Library: Green Boost uses Material UI. Amplify uses Amplify UI.\nHosting: Green Boost uses CDK constructs for transparent hosting. Amplify has proprietary hosting solution.\nSLA: Green Boost is developed and maintained by AWS Professional Services consultants in between projects. Amplify is developer and maintained by a dedicated AWS Service team."}},"/overview/guides/aws-credentials":{"title":"AWS Credentials","data":{"":"","the-problem#The Problem":"The simplest way to use AWS Security Credentials (AWS_ACCESS_KEY_ID, ...) is to copy and paste them from your provider (like IAM Identity Center) into your shell. However, what happens when you need to start a new shell process (new terminal tab) and still need your AWS credentials? You'll need to copy and paste them from your provider again 🙄.","aws-cli#AWS CLI":"In order to persist credentials between shell processes, you can use the ~/.aws/credentials and ~/.aws/config files which are automatically recognized by the AWS CLI, SDKs, and CDK.\nAWS recommends using temporary credentials using IAM Roles. Try to avoid using long-lived IAM User credentials.\nYou can persist credentials exported into your terminal with the following commands:\naws configure set aws_access_key_id \"$AWS_ACCESS_KEY_ID\"\naws configure set aws_secret_access_key \"$AWS_SECRET_ACCESS_KEY\"\naws configure set aws_session_token \"$AWS_SESSION_TOKEN\"\nCheckout your ~/.aws/credentials and ~/.aws/config to confirm the credentials have been saved:\ncat ~/.aws/credentials\nThis works, but what if you're switching between multiple AWS accounts and want to save different sets of credentials? We need a way to separate and identify sets of credentials. This is what the AWS_PRFOILE environment variable is for. You can append --profile \"$AWS_PROFILE\" to each of the previous aws configure set... commands with an exported AWS_PROFILE environment variable to identify sets of credentials.","alias#Alias":"To make the previous commands easier to run, you can create an alias, uac (update aws credentials), in your shell configuration file (.zschrc, ...) like below:\nalias uac='(\naws configure set aws_access_key_id \"$AWS_ACCESS_KEY_ID\" --profile \"$AWS_PROFILE\"\naws configure set aws_secret_access_key \"$AWS_SECRET_ACCESS_KEY\" --profile \"$AWS_PROFILE\"\naws configure set aws_session_token \"$AWS_SESSION_TOKEN\" --profile \"$AWS_PROFILE\"\necho \"AWS Credentials Updated ✅\"\n)'\nNow, with your AWS credentials and AWS_PROFILE in your shell process, you can simply run uac and your AWS credentials will be persisted but you'll need to ensure the AWS_PROFILE environment variable is set so that AWS tools know which persisted credentials to use. This is where direnv can help.","direnv#direnv":"direnv is an extension for your shell that loads and unloads environment variables in your current shell based on your current working directory. This means you can add a .envrc file at the root of your monorepo that looks like:\nexport AWS_PROFILE=my-profile\nThen run direnv allow{:bash} and now AWS_PROFILE will be set in any new shell process created within your monorepo. Prove this by running printenv | grep AWS{:bash}.\nYou'll notice in gboost create{:bash} templates, there are .envrc files already setup for you with commonly needed environment variables like AWS_PROFILE. We also include DB related environment variables so you easily connect to your DB locally. You're welcome to set other environment variables you commonly need within your .envrc file."}},"/overview/guides/clean-code":{"title":"Clean Code","data":{"":"","the-problem#The Problem":"There is no commonly agreed upon way to organize code for full stack cloud native web apps on AWS. This can make it challenging for greenfield projects to know where to start. Without a clear strategy for organizing code, projects can turn into a messy big ball of mud.In order to keep code architecture clean, this guide provides some recommendations for organizing your code. You do not have to follow it to build with Green Boost. However, keep in mind the less decisions you have to make as a developer, the faster you can build. Enforcing the right restrictions on your code can actually free you to focus on adding business value.\nFreedom is not the absence of restrictions but the presence of the right restrictions - Timothy Keller","file-structure#File Structure":"","core#core":"Center of your application.\nContains business logic.\nSubfolder structure inspired by the following design ideas. Learn more here.\nDomain Driven Design\nHexagonal Architecture\nVertical Slices\n\n\nPrimarily includes backend functionality.\nAdditionally includes common code shared between db, infra, and ui folders.\nTypical Request Path: User ↔ Primary Adapter ↔ Use Case ↔ Entity/Schema ↔ Repository ↔ Secondary Adapter ↔ External API","adaptersprimary#adapters/primary":"Bootstrap scripts that serve as the starting point of the program.\nConsidered primary adapters based on hexagonal architecture.\nDrive your application.\nDepend upon services.\nExamples includes Lambda handlers invoked by API Gateway EventBridge.","adapterssecondary#adapters/secondary":"Translate communication between the domain and the outside world.\nBased on hexagonal architecture, these are secondary adapters.\nExamples include a database repository, cache client, or email client.\nDon't contain business logic. Don't depend upon modules.","db#db":"DB related code\nStores migration files","modulesentity#modules/${entity}":"Entities represent a single instance of your domain object saved into the DB. See more here.\nHave UUID\nmodules/${entity}.db.ts\nDefines DB table for entity.\n\n\nmodules/${entity}.entity.ts\nClass including business logic related to this entity.\nDepends upon schema.\n\n\nmodules/${entity}/repository.ts\nTranslation layer between use case and secondary adapter.\nDepends on secondary adapter.\n\n\nmodules/${entity}/schema.ts\nValidation for entity to ensure business rules are followed.\nNo dependencies.\n\n\nmodules/${entity}/usecase.ts\nThin layer responsible for orchestrating collaboration between modules and adapters\nDepends upon entities, models,","modulesmodel#modules/${model}":"Models represents a real world object that is related to the domain space but not necessarily persisted. See more here.\nAlso known as value objects.\nDon't create anemic domain models which only consist of properties/attributes.","infra#infra":"AWS Cloud Development Kit (CDK) source code for defining stacks.","appstateful#app/stateful":"Collection of CDK Stacks that persist or store information on AWS.\nDeployed less infrequently.\nExamples include: network-stacks.ts, db-stack.ts, object-stack.ts.","appstateless#app/stateless":"Collection of CDK Stacks that do not persist or store information on AWS.\nDeployed frequently.\nExamples include: job-stack.ts, monitor-stack.ts, ui-stack.ts.","packages#packages":"Reusable modules across workspaces.\nExamples include TypeScript configuration and ESLint configuration.","ui#ui":"Web user interface code","app#app":"Define routing for Next.js filesystem based router.","components#components":"Reusable components found across routes.\nDon't add components here that are only used within a single routes.","context#context":"Application wide shared state that doesn't require prop-drilling.\nExamples include user information or preferences.","hooks#hooks":"Custom hooks which extract state from components allowing for reuse.\nUse when you find yourself copying and pasting ui code logic between components."}},"/overview/intro":{"title":"Welcome to Green Boost","data":{"":"Green Boost is a toolkit for building full stack cloud native web apps on AWS.","goals#Goals":"Boost developer productivity building greenfield web apps.\nProvide mechanisms to enforce security, infrastructure, and coding best practices.\nPropel developers into building business value faster with building blocks for common web app needs.\nHighlight open-source libraries and tools that improve developer productivity","motivation#Motivation":"Building a web app on AWS can feel daunting. There are many design decisions to make. While developing, there can be a lot of setup and boilerplate code. AWS Professional Services has experience building hundreds of web apps and we've learned some lessons along the way. We wanted to share with you these best practices while also providing an easy way to get started. That's why we built Green Boost.","tech-stack#Tech Stack":"Green Boost has opinions on what tech to use. A standard toolkit enables develoment teams to work faster together. 💪\nLanguage: TypeScript\nInfrastructure As Code: AWS Cloud Development Kit CDK\nBackend Runtime: Node.js\nFrontend Library: React\nFrontend Framework: Next.js"}},"/overview/packages":{"title":"Packages","data":{"":"Green Boost is published into 5 packages on NPM:\ngboost: Command Line Interface (CLI)\ngboost-common: Utility library to share commonly needed code between other libraries.\ngboost-infra: AWS CDK Constructs Library.\ngboost-node: Node.js backend code typically including functions run in AWS Lambda.\ngboost-ui: React UI Component Library built on Material UI and Next.js.\n\nEach package is versioned and released differently according to semantic versioning. Packages are only published as ES modules."}},"/overview/prereqs":{"title":"Prerequisites","data":{"":"In order to use Green Boost, you'll need to do the following:\nInstall Git\nInstall PNPM\nInstall/activate Node.js 18\nIf you don't have a way to manage your Node.js versions, we recommend PNPM's built in pnpm env command where you can use the latest version of Node.js 18 with: pnpm env use --global 18\n\n\nSetup an AWS Account\nIf you're building a production grade web app, we recommend using a well-architected, multi-account AWS environment with Landing Zone. Leare more here.\n\n\nBootstrap AWS Account with the CDK\ncdk bootstrap aws://<account-number>/<region>\n\n\nInject your AWS credentials into your terminal\nNot sure how to manage your AWS credentials? Checkout our guide here."}},"/overview/quick-start":{"title":"Quick Start","data":{"":"Follow the prerequisites.\nInstall the Green Boost CLI: pnpm add -g gboost.\nCreate a web app with: gboost create.\nFollow the prompts to select a template, directory, app id, and app title. To learn more about gboost create and the templates available, learn more here.\nChange directory into your directory: cd <your-directory>\nInstall dependencies: pnpm i.\nChange directory into the infrastructure folder: cd infra\nDeploy: pnpm deploy:local\nView your web app the CloudFront URL printed in your terminal towards the end of output from the previous command.\nClean up: pnpm destroy:local."}},"/ui/intro":{"title":"UI Introduction","data":{"":"Welcome to the docs for gboost-ui."}},"/overview/guides/config":{"title":"Configuration","data":{"":"","the-problem#The Problem":"There are many places you could store your configuration with your full stack cloud native web apps on AWS including: static code, environment variables, Amazon S3, AWS Systems Manager Parameter Store, AWS Secrets Manager, AWS AppConfig, and more! Where you do you store your configuration? Additionally, when working with Next.js, how do we ensure server configuration doesn't get included in client bundles?","balanced-approach#Balanced Approach":"We believe using static code for most configuration and AWS SSM Parameter Store Secure Strings for most secrets is a great balance between simplicity and features. Static code configuration is simple to create, easy to dynamically utilize based on environment, version controlled, and updated on each deployment. AWS SSM Parameter Store Secure Strings is simple and inexpensive. If you have enterprise grade configuration management needs or dynamic configuration, please consider AWS AppConfig and AWS Secrets Manager.","shared-configuration#Shared Configuration":"In every source (src) directory of Green Boost templates, there is a config folder. This folder contains the static code configuration for the application. For example, look at core/src/config/shared-config.ts from the BasicUI template below:\nexport class SharedConfig {\nstatic appId = \"myapp\";\nconstructor(stageName?: string) {\nthis.stageName = stageName || StageName.Local;\n}\nget enumStageName(): StageName {\nreturn Object.values(StageName).includes(this.stageName as StageName)\n? (this.stageName as StageName)\n: StageName.Local;\n}\nget isLocal() {\nreturn this.enumStageName === StageName.Local;\n}\nget isProd() {\nreturn this.enumStageName === StageName.Prod;\n}\nstageName: string;\n}\nThis configuration class gives us key information about our application so that we can change the behavior of based on it's stage or environment. For example, in development we can only deploy a single writer instance as the load on our DB in development is low but in production we can add additional reader instances. Using code to store our configuration in a class means we can export the configuration class to other workspaces (infra, ui, etc.) and then inherit from this class to easily use the configuration in different environments.","keep-server-configuration-out-of-client-components#Keep Server Configuration out of Client Components":"The above shared configuration pattern can be used throughout our app. But what happens when begin to add configuration that we want to make sure isn't exposed on the client? For example, checkout core/src/config/server-config.ts from the CRUDPostgres template below:\nexport class ServerConfig extends SharedConfig {\nstatic get dbAdminUsername() {\nreturn `${SharedConfig.appId}_admin`;\n}\nstatic get dbIamUsername() {\nreturn `${SharedConfig.appId}_iam_user`;\n}\nstatic get dbName() {\nreturn `${SharedConfig.appId}_db`;\n}\nstatic envVarNames = {\nSTAGE_NAME: \"STAGE_NAME\",\nNEXT_PUBLIC_STAGE_NAME: \"NEXT_PUBLIC_STAGE_NAME\",\n};\nconstructor(stageName?: string) {\nsuper(stageName || StageName.Local);\n}\n}\nWe want to make sure the database configuration values are not accidentally included on the client side. To do this, we can export our server configuration from a sub-module export through core/package.json#exports called \"server\". Then in our ESLint configuration at /packages/eslint-config-next we can create a rule prevents importing from @myapp/core/server where the name of the package in core/ is @myapp/core. Then we can create a ui/src/core-server.ts like below:\nimport \"server-only\"; // prevents server code from being bundled into client code\n// eslint-disable-next-line no-restricted-imports\nexport * from \"@myapp1/core/server\";\nHere, we temporarily disable the eslint restriction to gain access to the configuration and re-export the value but we ensure to import the server-only package. This package ensures that only React Server Components can safely import this file. If a client component attempts to import the code, the build will fail. Additionally, if you try import from @myapp1/core/server within your ui folder, you'll get the (good) error: import is restricted from being used. Importing from @myapp/core/server directly could result in server code leaking into the client. Please import from '@/core-server'. 🛡️.","secret-configuration#Secret Configuration":"When you need to use secrets within your application, do not statically include secrets in your code or through static environment variables. At runtime, fetch the secrets and use them or dynamically inject them into your environment if needed. Use @aws-sdk/client-ssm with the GetParameterCommand to fetch secure strings. Don't forget to set WithDecryption: true."}}}